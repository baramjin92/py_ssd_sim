#!/usr/bin/python

import os
import sys
import random
import numpy as np
import pandas as pd

# in order to import module from parent path
sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))

from config.sim_config import unit
from config.sim_config import nand_info
from config.ssd_param import *

from sim_event import *

# define state
NAND_STATE_IDLE = 0
NAND_STATE_SENSE = 1
NAND_STATE_XFER_W = 2
NAND_STATE_PROGRAM = 3
NAND_STATE_ERASE = 4

# define cell status
NAND_STATUS_ERASE = 0x00
NAND_STATUS_PROGRAM = 0x80

def log_print(message) :
	event_log_print('[nand]', message)

# nand class represent one die of nand
# it manages data with nand_ctx
class nand_context :
	def __init__(self, nand_id, block_num, page_num, plane_num) :
		self.nand_id = nand_id

		# nand information (it manages cell of nand)		
		# block = main_block + spare_block (additional block + extended block)
		self.block_num = block_num
		self.page_num = page_num
		self.plane_num = plane_num
		self.chunks_per_blk = self.page_num * CHUNKS_PER_PAGE
		
		# nand page buffer information (it manages operation of nand)
		self.state = NAND_STATE_IDLE
		self.nand_addr = 0
		self.main_data = []
		self.meta_data = []
		self.chunks_num = 0
	
		# reserve area for nand
		# cell structure : cell[block][chunk]
		self.cell = np.empty((self.block_num, self.chunks_per_blk), np.int64)
		self.status = np.zeros(self.block_num, np.int8)
		#log_print(self.cell.shape)	

	def set_address(self, addr) :
		self.nand_addr = addr
		
	def get_date(self) :
		return self.main_data

	def read_page(self) :
		# nand address is composed by block, page, chunk offset
		# it can be separated by CHUNK_PER_WAY,  CHUNK_PER_BLOCK, CHUNK_PER_PAGE
		# get block and page address of nand
		nand_block = int(self.nand_addr / CHUNKS_PER_BLOCK) 
		nand_page = int((self.nand_addr % CHUNKS_PER_BLOCK) / CHUNKS_PER_PAGE)
		chunk_offset = int((self.nand_addr % CHUNKS_PER_PAGE))
				
		log_print('die %d read block %x page %d'%(self.nand_id, nand_block, nand_page))
				
		# calculte chunk index in page
		chunk_addr = nand_page * CHUNKS_PER_PAGE
	
		#for index in range(self.chunks_num) :
		for chunk_index in range(chunk_addr, chunk_addr+CHUNKS_PER_PAGE) :
			# read data from nand
			nand_data = self.cell[nand_block][chunk_index]
									
			# set main data/extra data
			self.main_data.append((nand_data & 0xFFFFFFFF))
			self.meta_data.append((nand_data >> 32) & 0xFFFFFFFF)
			
	def program_page(self) :
		# nand address is composed by block, page, chunk offset
		# it can be separated by CHUNK_PER_WAY,  CHUNK_PER_BLOCK, CHUNK_PER_PAGE
		# get block and page address of nand
		nand_block = int(self.nand_addr / CHUNKS_PER_BLOCK) 
		nand_page = int((self.nand_addr % CHUNKS_PER_BLOCK) / CHUNKS_PER_PAGE)
		chunk_offset = int((self.nand_addr % CHUNKS_PER_PAGE))
				
		log_print('die %d program block %x page %s'%(self.nand_id, nand_block, nand_page))

		self.status[nand_block] = self.status[nand_block] | NAND_STATUS_PROGRAM
						
		# calculte chunk index in page
		chunk_index = nand_page * CHUNKS_PER_PAGE + chunk_offset
								
		# the data can distinguish with main data and extra data
		# main data means user data to save
		# extra data means data which is saved in spare area, for example meta data or CRC data, it can be generated by FW or HW(Controller)

		# In this simulator, main data is reduced to 4Byte (representative value) in order to saving memory for simulation
		for index in range(self.chunks_num) :			
			# get main data/extra data in order to combine
			main_data = self.main_data[index]
			meta_data = self.meta_data[index]
			
			# make nand data (8Byte)
			nand_data = (meta_data << 32) | main_data
			 
			# save nand data
			self.cell[nand_block][chunk_index] = nand_data
			
			# increas chunk address
			chunk_index = chunk_index + 1
			
			log_print('main data : %d, meta_data : %d'%(main_data, meta_data))
									  
		return True
								
	def erase_block(self) :
		# get block address of nand
		nand_block = int(self.nand_addr / CHUNKS_PER_BLOCK)

		log_print('die %d erase block %x'%(self.nand_id, nand_block)) 
				
		# calculate number of chunks for block
		for index in range(self.chunks_per_blk) :
			self.cell[nand_block][index] = 0
			self.status[nand_block] = 0
		
		return True		
		
	def calculate_tR(self) :
		# make tR (mean, max deviation) 
		
		# get mean time by the page num (LSB/MSB in MLC, LSB/CSB/MSB in TLC)

		nand_block = int(self.nand_addr / CHUNKS_PER_BLOCK) 
		mode = self.status[nand_block] & 0x03		
		
		# tR calculation will be changed
		if mode == NAND_MODE_MLC :
			mean = nand_info.nand_t_read_full
		elif mode == NAND_MODE_TLC :  
			mean = nand_info.nand_t_read_full
		elif mode == NAND_MODE_SLC :
			mean = 30*1000
		elif mode == NAND_MODE_QLC :
			mean = 120*1000
			
		# deviation is 3% from mean
		diviation = mean * 0.03
			
		# generate tR by randomize funtion
		tR = random.randrange(int(mean - diviation), int(mean + diviation))
		
		# unit (ns)
		return tR		
		
	def calculate_tProg(self) :
		# make tPROG (mean, max deviation) 
		
		# get mean time by the page num (LSB/MSB in MLC, LSB/CSB/MSB in TLC)

		nand_block = int(self.nand_addr / CHUNKS_PER_BLOCK) 
		mode = self.status[nand_block] & 0x03		
				
		# tProg calculation will be changed
		if mode == NAND_MODE_MLC :
			mean = nand_info.nand_t_prog_avg
		elif mode == NAND_MODE_TLC :
			mean = nand_info.nand_t_prog_avg
		elif mode == NAND_MODE_SLC :
			mean = nand_info.nand_t_prog_slc
		elif mode == NAND_MODE_QLC :
			mean = 3000
								
		# deviation is 1% from mean (5% -> 1%)
		diviation = mean * 0.01
			
		# generate tProg by randomize funtion
		tPROG = random.randrange(int(mean - diviation), int(mean + diviation))

		# unit (ns)		
		return tPROG
		
	def calculate_tBER(self) :
		# so far, we don't distinguish tBERS by mode 
		# it will be changed later

		nand_block = int(self.nand_addr / CHUNKS_PER_BLOCK) 
		mode = self.status[nand_block] & 0x03		

		# make tBERS (min, max)
		nand_t_bers = nand_info.nand_t_bers
		
		# deviation is 10%
		min = nand_t_bers * 0.9
		max = nand_t_bers * 1.1
		# generate tBER by randomize funtion
		tBERS = random.randrange(min, max) 

		# unit (ns)		
		return tBERS
		
	def set_mode(self, mode) :
		nand_block = int(self.nand_addr / CHUNKS_PER_BLOCK) 
		
		value = self.status[nand_block] & ~0x03
		value = value | mode
		self.status[nand_block] = value		
		
		log_print('change mode - way : %d, block : %d, mode : %d'%(self.nand_id, nand_block, mode))

	def print_block_data(self, nand_block, start_page, end_page) :

		print('nand data - block : %d, start page : %d, end page : %d'%(nand_block, start_page, end_page))
		unit = 2
		str = ''		
		for nand_page in range(start_page, end_page) :
			# read data from nand
			for chunk in range(CHUNKS_PER_PAGE) :
				chunk_index  = nand_page * CHUNKS_PER_PAGE + chunk
				nand_data = self.cell[nand_block][chunk_index]
				
				# set main data/extra data
				nand_data = nand_data & 0xFFFFFFFF
				#meta_data.append((nand_data >> 32) & 0xFFFFFFFF)
							
				chunk_value = '%04d '%(nand_data)					
				str = str + chunk_value
					
			if nand_page % unit == (unit - 1) :
				print(str)
				str = ''
			else :	
				str = str + '/ '
																													
class nand_manager :
	def __init__(self, nand_num, nand_info) :
		# set nand basic information and ac parameter
		self.nand_info = nand_info
		
		# set nand context
		block_num = nand_info.main_block_num + nand_info.spare_block_num
		self.nand_ctx = []
		for index in range(nand_num) :
			self.nand_ctx.append(nand_context(index, block_num, nand_info.page_num, nand_info.plane_num))
															
	def get_nand_info(self) :
		return self.nand_info												
													
	def begin_new_command(self, nand, event) :
		# get nand command and address from event
		nand.nand_addr = event.nand_addr
		nand.chunks_num = event.chunk_num
		nand.main_data.clear()
		nand.meta_data.clear()

		nand_cmd = event.cmd_code

		if nand.nand_addr == 0 :
			print('begin new cmd : %d, id : %d, addr : %x, chunks : %d'%(nand_cmd, nand.nand_id, nand.nand_addr, nand.chunks_num))
															
		# check nand cmd 
		if nand_cmd == NAND_CMD_READ:
			nand.state = NAND_STATE_SENSE

			# save option for NAND_CMD_READ

			# calculate tR and alloc next event			
			tR = nand.calculate_tR()
			next_event = event_mgr.alloc_new_event(tR)
			next_event.code = event_id.EVENT_NAND_SENSE_END
			next_event.dest = event_dst.MODEL_NAND | event_dst.MODEL_NFC
			next_event.nand_id = nand.nand_id								
												
		elif nand_cmd == NAND_CMD_PROGRAM :
			nand.state = NAND_STATE_XFER_W															
																																																
		elif nand_cmd == NAND_CMD_ERASE:
			nand.state = NAND_STATE_ERASE
			
			# calculate tBERS and alloc next event
			tBERS = nand.calculate_tBER() 
			next_event = event_mgr.alloc_new_event(tBERS)
			next_event.code = event_id.EVENT_NAND_ERASE_END
			next_event.dest = event_dst.MODEL_NAND | event_dst.MODEL_NFC
			next_event.nand_id = nand.nand_id
			
		elif nand_cmd == NAND_CMD_MODE :
			nand.set_mode(int(event.chunk_num))								
												
	def event_handler(self, event) :
		# print('[nand_event_handler] %d' %(event.code))
		
		# from event, get nand_id and nand context
		nand = self.nand_ctx[event.nand_id]
		
		# from nand context, get current state of nand
		# nand is variable of nand context
		# nand.state is state variable for each nand 
		
		if event.code == event_id.EVENT_NAND_CNA_END :
			self.begin_new_command(nand, event)
					
		elif event.code == event_id.EVENT_NAND_SENSE_END :
			# check current state, it should be NAND_STATE_SENSE
			
			nand.read_page()
			
			nand.state = NAND_STATE_IDLE
				
		elif event.code == event_id.EVENT_NAND_ERASE_END :
			# check current state, it should be NAND_STATE_ERASE
			
			nand.erase_block()			
			nand.state = NAND_STATE_IDLE		
			
		elif event.code == event_id.EVENT_NAND_PROG_END :
			# check current state, it should be NAND_STATE_PROGRAM
			
			nand.program_page()		
			nand.state = NAND_STATE_IDLE		
			
		elif event.code == event_id.EVENT_NAND_DIN_END :
			# check current state, it should be NAND_STATE_XFER_W

			# move data from event to nand		

			nand.chunks_num = event.chunk_num
			for index in range(nand.chunks_num) :
				#log_print('NAND DIN %d, %d'%(event.main_data[index], event.meta_data[index]))
				nand.main_data.append(event.main_data[index])
				nand.meta_data.append(event.meta_data[index])
			
			# todo : option = event.option
			
			nand.state = NAND_STATE_PROGRAM

			# calculate tProg and alloc next event
			tPROG = nand.calculate_tProg()
			next_event = event_mgr.alloc_new_event(tPROG)
			next_event.code = event_id.EVENT_NAND_PROG_END
			next_event.dest = event_dst.MODEL_NAND | event_dst.MODEL_NFC
			next_event.nand_id = nand.nand_id								
			
		elif event.code == event_id.EVENT_NAND_DOUT_END :
			# check current state, it should be NAND_STATE_IDLE

			chunk_offset = event.chunk_offset
			
			event.main_data.clear()
			event.main_data.append(nand.main_data[chunk_offset])			
			event.meta_data.clear()
			event.meta_data.append(nand.meta_data[chunk_offset])
			
			if nand.meta_data[chunk_offset] == 0 and nand.main_data[chunk_offset] == 0 :
				print('nand id : %d, nand read page - address : %d, chunk_offset : %d, main_data : %d, meta_data : %d'%(nand.nand_id, nand.nand_addr, chunk_offset, nand.main_data[chunk_offset], nand.meta_data[chunk_offset]))
			
		elif event.code == event_id.EVENT_NAND_CHK_BEGIN :						
			# Because nand is idle, it requite to NFC checking nand state 

			# alloc next event with time (NAND_T_CHK)
			next_event = event_mgr.alloc_new_event(nand_info.nand_t_chk)
			next_event.code = event_id.EVENT_NAND_CHK_END
			next_event.dest = event_dst.MODEL_NFC
			next_event.nand_id = nand.nand_id								
		
		return True						

	def print_param(self) :
		print('nand parameter')
		
		param = self.nand_info
		param_name = {'name' : ['extra_data_size', 'crc_size', 'ecc_size', 'nand_t_cna_w', 'nand_t_cna_r', 'nand_t_cna_e', 'nand_t_chk', 'nand_t_xfer', 'nand_t_read_lsb', 'nand_t_read_msb', 'nand_t_prog_lsb', 'nand_t_prog_msb', 'nand_t_bers']}				
						
		param_pd = pd.DataFrame(param_name)				
						
		param_columns = []
		param_columns.append(param.extra_data_size)
		param_columns.append(param.crc_size)
		param_columns.append(param.ecc_size)
		
		param_columns.append(param.nand_t_cna_w)
		param_columns.append(param.nand_t_cna_r)
		param_columns.append(param.nand_t_cna_e)
		param_columns.append(param.nand_t_chk)
		param_columns.append(param.nand_t_xfer)
		
		param_columns.append(param.nand_t_read_lsb)
		param_columns.append(param.nand_t_read_msb)
		param_columns.append(param.nand_t_prog_lsb)
		param_columns.append(param.nand_t_prog_msb)
		param_columns.append(param.nand_t_bers)
																		
		param_pd['value'] = pd.Series(param_columns, index=param_pd.index)
		
		print(param_pd)								

	def print_type(self) :
		print('nand type')

		info = self.nand_info

		# calculate ssd information
		bit_per_cel = 3
		small_block_size = info.page_size * info.page_num
		big_block_size = small_block_size * info.plane_num
	
		info_name = {'name' : ['bit per cell', 'capacity[Gb]', 'page size[KB]', 'page num', 'plane num', 'wordline num', 'block num', 'small block size[MB]', 'big block size[MB]']}				
						
		info_pd = pd.DataFrame(info_name)				
						
		info_columns = []
		info_columns.append(bit_per_cel)
		info_columns.append(info.size)
		info_columns.append(info.page_size / unit.scale_KB)
		info_columns.append(info.page_num)
		info_columns.append(info.plane_num)
		info_columns.append(info.page_num / bit_per_cel)
		info_columns.append(info.main_block_num)
		info_columns.append(int(small_block_size / unit.scale_MB))
		info_columns.append(int(big_block_size / unit.scale_MB))
																		
		info_pd['value'] = pd.Series(info_columns, index=info_pd.index)

		print(info_pd)											
																																										
class nand_statistics :
	def __init__(self) :
		log_print('nand statstics init')
		
	def print(self) :
		log_print('nand statstics')
																		
def unit_test_nand() :		
	nand_mgr = nand_manager(2, nand_info)	
	
	nand_mgr.print_type()
	nand_mgr.print_param()
	
	nand = nand_mgr.nand_ctx[0]
	nand.print_block_data(0, 0, 10)			
										
if __name__ == '__main__' :
	print ('module nand main')			
			
	unit_test_nand()		
																	